#!/usr/bin/env python

import json
import os
import re
import sys

sys.path.insert(1, os.path.join(sys.path[0], ".."))

import dot_init

import asyncclick as click

import services.anthropic
import services.console
import services.tools
import services.tools.anthropic
import services.tools.exa
import services.tools.parallel


@click.group()
def cli():
    pass



@click.command()
@click.option("--query", "query", default=None, required=True, help="user query")
@click.option("--file", "file", default=None, required=True, help="input file path")
async def anth_cite(query: str, file: str) -> int:
    """
    Run anthropic cite tool.

    The input file can be txt or json.
    """
    match = re.search(r"(json|txt)$", file)

    if not match:
        services.console.print_error("file invalid")
        exit(-1)

    with open(file, "r") as f:
        data = f.read()
        title = file.split("/")[-1]

        if match[1] == "json":
            doc = services.anthropic.DocCustom(
                content=[], # todo
                title=title,
            )
        elif match[1] == "txt":
            doc = services.anthropic.DocText(
                data=data,
                title=title,
            )

    response_dict = await services.tools.anthropic.anth_cite(context=None, query=query, doc=doc)

    print(json.dumps(response_dict, indent=2))


@click.command()
@click.option("--query", "query", default=None, required=True, help="user query")
@click.option("--max-uses", "max_uses", default=1, required=True, help="max search queries")
async def anth_search(query: str, max_uses: int) -> int:
    """
    Run anthropic web_search tool
    """
    response_dict = await services.tools.anthropic.anth_search(context=None, query=query, max_uses=max_uses)

    print(json.dumps(response_dict, indent=2))


@click.command()
@click.option("--query", "query", default=None, required=True, help="user query")
@click.option(
    "--text", "text", default=False, is_flag=True, type=bool, required=False, help="if response includes full text content in the search results"
)
async def exa_answer(query: str, text: bool) -> int:
    """
    Run exa answer tool
    """
    result_dict = await services.tools.exa.exa_answer(context=None, query=query, text=text)

    print(json.dumps(result_dict, indent=2))


@click.command()
@click.option("--query", "query", default=None, required=True, help="user query")
@click.option("--type", "type", default="auto", required=False, help="search type, one of 'keyword', 'neural', 'fast', 'auto'")
@click.option("--contents-summary", "c_summary", default=False, is_flag=True, type=bool, required=False, help="include contents summary")
@click.option("--contents-text", "c_text", default=False, is_flag=True, type=bool, required=False, help="include contents full text")
async def exa_search(query: str, type: str, c_summary: bool, c_text: bool) -> int:
    """
    Run exa search tool
    """
    contents = {}

    if c_summary:
        contents["summary"] = True

    if c_text:
        contents["text"] = True

    results_list = await services.tools.exa.exa_search(context=None, query=query, type=type, contents=contents, limit=10)

    for i, result in enumerate(results_list):
        print(f"result {i+1}:")
        print(json.dumps(result, indent=2))
        print("")


@click.command()
@click.option("--query", "query", default=None, required=True, help="user query")
async def par_search(query: str) -> int:
    """
    Run parallel.ai search tool
    """
    results_list = await services.tools.parallel.par_search(context=None, objective=query, search_queries=[])

    for i, result in enumerate(results_list):
        print(f"result {i+1}:")
        print(json.dumps(result, indent=2))
        print("")


cli.add_command(anth_cite)
cli.add_command(anth_search)
cli.add_command(exa_answer)
cli.add_command(exa_search)
cli.add_command(par_search)

if __name__ == "__main__":
    cli()
