#!/usr/bin/env python

import json
import os
import re
import sys

sys.path.insert(1, os.path.join(sys.path[0], ".."))

import dot_init

import asyncclick as click
import pydantic_ai.agent
import pydantic_core
import ulid

import models
import services.agents
import services.console
import services.convs
import services.convs.msgs
import services.database.session
import services.places.functions
import services.tools


@click.group()
def cli():
    pass

@click.command()
@click.pass_context
@click.option("--id", "conv_ids", default=None, type=str, required=True, help="conv id")
async def conv_delete(ctx, conv_ids: str) -> int:
    """
    Delete an existing conversation
    """
    conv_ids = [int(id) for id in conv_ids.split(",")]

    with services.database.session.get() as db_session:
        for conv_id in conv_ids:
            code, msg_ids = services.convs.delete_by_id(db_session, id=conv_id)

            if code != 0:
                services.console.print_error(f"conv id {conv_id} delete error {code}")
                continue
            
            services.console.print_ok(f"conv_id {conv_id}, msg_ids {msg_ids} deleted")


@click.command()
@click.pass_context
@click.option("--id", "conv_id", default=None, required=True, help="conv id")
async def conv_load(ctx, conv_id: int) -> int:
    """
    Load an existing conversation
    """
    print("")

    with services.database.session.get() as db_session:
        conv_db = services.convs.get_by_id(db_session, id=conv_id)

        if not conv_db:
            services.console.print_error(f"conv {conv_id} invalid")
            exit(-1)

        _code, model_msgs = services.convs.msgs.load_by_conv_id(db_session=db_session, conv_id=conv_id)

        for model_msg in model_msgs:
            if model_msg.kind == "request":
                output_str = services.agents.output_model_request(msg=model_msg)
                services.console.print_fragment_user(output_str, end="\n\n")
            elif model_msg.kind == "response":
                output_str = services.agents.output_model_response(msg=model_msg)
                services.console.print_fragment_system(output_str, end="\n\n")

    await ctx.invoke(conv_start, user_id=conv_db.user_id, conv_id=conv_db.id)

@click.command()
@click.option("--user-id", "user_id", default=1, required=False, help="user id")
@click.option("--conv-id", "conv_id", default=0, required=False, help="conv id to resume")
async def conv_start(user_id: int, conv_id: int) -> int:
    """
    Start or resume a conversation
    """
    #
    # the pydantic_ai framework distinguishes between tools and output types.
    # 
    # tools are used during the user turn to run and provide data for the query.
    # output types are called during a user turn and end that turn with their output.
    #

    agent_anth = services.agents.create_agent_general(
        model=services.agents.model_anthropic(),
        tools=[], # services.tools.list(),
    )

    agent_places = services.agents.create_agent_places(
        model=services.agents.model_gemini(),
        output_types=services.places.functions.list(),
    )

    conv_db: models.ConvObj = None
    msgs_history = []

    while True:
        user_query = input("\x1b[1;33muser: \x1b[0m")

        if re.match(r"^(bye|exit|quit)", user_query):
            services.console.print_status("\nconversation exiting")
            break

        if re.match(r"^(break|breakpoint|debug)", user_query):
            services.console.print_status("\nconversation debugger")
            breakpoint()

        print("")

        with services.database.session.get() as db_session:
            tool_use = services.places.functions.match_tool_use(db_session=db_session, query=user_query)

            if tool_use:
                agent_result = await agent_places.run(user_prompt=user_query, deps={})

                services.console.print_fragment_system(
                    services.agents.output_tool(output=agent_result.output)
                )
                print("")

                print(f"messages turn size {len(agent_result.new_messages())}") # xxx
            else:
                if not conv_db:
                    if conv_id == 0:
                        # create new conversation
                        code, conv_db = services.convs.create(db_session=db_session, name=f"c-{ulid.new().str}", user_id=user_id)
                    else:
                        conv_db = services.convs.get_by_id(db_session=db_session, id=conv_id)

                agent_deps = {
                    "conv_id": conv_db.id,
                    "user_id": user_id,
                }

                async with agent_anth.iter(user_prompt=user_query, message_history=msgs_history, deps=agent_deps) as agent_run:
                    async for node in agent_run:
                        # print(node)
                        # print("")
                        output_struct = services.agents.output_node(node=node)

                        if output_struct.kind == "request":
                            services.console.print_fragment_user(output_struct.text, end="\n\n")
                        elif output_struct.kind == "response":
                            services.console.print_fragment_system(output_struct.text, end="\n\n")
                        elif output_struct.kind == "end":
                            pass # skip

                    agent_result = agent_run.result
                    model_msgs = agent_result.new_messages()

                    services.console.print_fragment_system(agent_result.output)
                    print("\r\n")

                    msgs_history.extend(model_msgs)

                    services.convs.msgs.persist(
                        db_session=db_session, conv_id=conv_db.id, user_id=user_id, model_msgs=model_msgs
                    )

    return 0

cli.add_command(conv_delete)
cli.add_command(conv_load)
cli.add_command(conv_start)

if __name__ == "__main__":
    cli()
