#!/usr/bin/env python

import json
import os
import re
import sys

sys.path.insert(1, os.path.join(sys.path[0], ".."))

import dot_init

import asyncclick as click
import ulid

import services.agents
import services.console
import services.convs
import services.convs.msgs
import services.database.session
import services.places.functions
import services.tools


@click.group()
def cli():
    pass

@click.command()
@click.pass_context
@click.option("--ids", "conv_ids", default=None, type=str, required=True, help="conv id")
async def conv_delete(ctx, conv_ids: str) -> int:
    """
    Delete an existing conversation
    """
    conv_ids = [int(id) for id in conv_ids.split(",")]

    with services.database.session.get() as db_session:
        for conv_id in conv_ids:
            code, msg_ids = services.convs.delete_by_id(db_session, id=conv_id)

            if code != 0:
                services.console.print_error(f"conv id {conv_id} delete error {code}")
                continue
            
            services.console.print_ok(f"conv_id {conv_id}, msg_ids {msg_ids} deleted")


@click.command()
@click.pass_context
@click.option("--id", "conv_id", default=None, required=True, help="conv id")
async def conv_load(ctx, conv_id: int) -> int:
    """
    Load an existing conversation
    """
    print("")

    with services.database.session.get() as db_session:
        conv_db = services.convs.get_by_id(db_session, id=conv_id)

        if not conv_db:
            services.console.print_error(f"conv {conv_id} invalid")
            exit(-1)

        _code, model_msgs = services.convs.msgs.load_by_conv_id(db_session=db_session, conv_id=conv_id)

        for model_msg in model_msgs:
            output_struct = services.agents.output_model_msg(model_msg=model_msg)
            output_nodes = output_struct.nodes
            node_index = 0

            while node_index < len(output_nodes):
                output_node = output_nodes[node_index]

                if output_node.name in ["user-prompt"]:
                    services.console.print_fragment_user(f"user: {output_node.text}", end="\n\n")
                elif output_node.name in ["builtin-tool-call", "builtin-tool-return", "tool-call", "tool-return"]:
                    services.console.print_fragment_tool(f"{output_node.name}: {output_node.text}", end="\n\n")
                elif output_node.name in ["model-text"]:
                    # collect model-text nodes
                    node_index, text = services.agents.output_nodes_collect(
                        output_nodes=output_nodes, name="model-text", index=node_index
                    )
                    services.console.print_fragment_model(text, end="\n\n")
                elif output_node.name in ["model-end"]:
                    # todo
                    services.console.print_fragment_model("model-end", end="\n\n")

                node_index += 1

    await ctx.invoke(conv_start, user_id=conv_db.user_id, conv_id=conv_db.id)

@click.command()
@click.option("--user-id", "user_id", default=1, required=False, help="user id")
@click.option("--conv-id", "conv_id", default=0, required=False, help="conv id to resume")
async def conv_start(user_id: int, conv_id: int) -> int:
    """
    Start or resume a conversation
    """
    #
    # the pydantic_ai framework distinguishes between tools and output types.
    # 
    # tools are used during the user turn to run and provide data for the query.
    # output types are called during a user turn and end that turn with their output.
    #

    agent_anth = services.agents.create_agent_general(
        model=services.agents.model_anthropic(),
        tools=[], # services.tools.list(),
    )

    agent_places = services.agents.create_agent_places(
        model=services.agents.model_gemini(),
        output_types=services.places.functions.list(),
    )

    msgs_history = []

    while True:
        user_query = input("user: ")

        if re.match(r"^(bye|exit|quit)", user_query):
            services.console.print_ok(f"\nconversation {conv_id} exiting")
            break

        if re.match(r"^(break|breakpoint|debug)", user_query):
            services.console.print_ok(f"\nconversation {conv_id} debugger")
            breakpoint()

        print("")

        with services.database.session.get() as db_session:
            tool_use = services.places.functions.match_tool_use(db_session=db_session, query=user_query)

            if tool_use:
                agent_result = await agent_places.run(user_prompt=user_query, deps={})

                services.console.print_fragment_model(
                    services.agents.output_tool(output=agent_result.output)
                )
                print("")

                print(f"messages turn size {len(agent_result.new_messages())}") # xxx
            else:
                if conv_id == 0:
                    # create new conversation
                    code, conv_db = services.convs.create(db_session=db_session, name=f"c-{ulid.new().str}", user_id=user_id)
                else:
                    conv_db = services.convs.get_by_id(db_session=db_session, id=conv_id)

                conv_id = conv_db.id

                agent_deps = {
                    "conv_id": conv_id,
                    "user_id": user_id,
                }

                async with agent_anth.iter(user_prompt=user_query, message_history=msgs_history, deps=agent_deps) as agent_run:
                    async for node in agent_run:
                        output_struct = services.agents.output_nodes(node=node)
                        output_nodes = output_struct.nodes
                        node_index = 0

                        while node_index < len(output_nodes):
                            output_node = output_nodes[node_index]

                            if output_node.name in ["user-prompt"]:
                                # this script is interactive so the user prompt is already on display
                                pass
                            elif output_node.name in ["builtin-tool-call", "builtin-tool-return", "tool-call", "tool-return"]:
                                services.console.print_fragment_tool(f"{output_node.name}: {output_node.text}", end="\n\n")
                            elif output_node.name in ["model-text"]:
                                # collect model-text nodes
                                node_index, text = services.agents.output_nodes_collect(
                                    output_nodes=output_nodes, name="model-text", index=node_index
                                )
                                services.console.print_fragment_model(text, end="\n\n")
                            elif output_node.name in ["model-end"]:
                                pass

                            node_index += 1

                    agent_result = agent_run.result
                    model_msgs = agent_result.new_messages()

                    msgs_history.extend(model_msgs)

                    services.convs.msgs.persist(
                        db_session=db_session, conv_id=conv_db.id, user_id=user_id, model_msgs=model_msgs
                    )

    return 0

cli.add_command(conv_delete)
cli.add_command(conv_load)
cli.add_command(conv_start)

if __name__ == "__main__":
    cli()
