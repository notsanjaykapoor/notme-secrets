#!/usr/bin/env python

import asyncio
import os
import re
import sys

sys.path.insert(1, os.path.join(sys.path[0], ".."))

import dot_init

import asyncclick as click
import logfire
import pydantic_ai
import pydantic_ai.messages
import ulid

import models
import services.agents
import services.console
import services.convs
import services.convs.reqs
import services.database.session
import services.places.functions
import services.tools


@click.group()
def cli():
    pass


@click.command()
@click.pass_context
@click.option("--ids", "conv_ids", default=None, type=str, required=True, help="conv id")
async def conv_delete(ctx, conv_ids: str) -> int:
    """
    Delete an existing conversation
    """
    conv_ids = [int(id) for id in conv_ids.split(",")]

    with services.database.session.get() as db_session:
        for conv_id in conv_ids:
            code, reqs_ids, msg_ids = services.convs.delete_by_id(db_session, id=conv_id)

            if code != 0:
                services.console.print_error(f"conv id {conv_id} delete error {code}")
                continue

            services.console.print_ok(f"conv_id {conv_id}, reqs_ids {reqs_ids}, msg_ids {msg_ids} deleted")


@click.command()
@click.pass_context
@click.option("--id", "conv_id", default=None, type=int, required=True, help="conv id")
async def conv_load(ctx, conv_id: int) -> int:
    """
    Load an existing conversation
    """
    with services.database.session.get() as db_session:
        conv_db = services.convs.get_by_id(db_session, id=conv_id)

        if not conv_db:
            services.console.print_error(f"conv {conv_id} invalid")
            exit(-1)

        user_id = conv_db.user_id

    await _conv_stream(conv_id=conv_id, user_id=user_id)


@click.command()
@click.option("--user-id", "user_id", default=1, type=int, required=False, help="user id")
async def conv_start(user_id: int) -> int:
    """
    Start a new conversation
    """
    await _conv_stream(conv_id=0, user_id=user_id)


async def _conv_stream(conv_id: int, user_id: int):
    """
    Stream a new or existing conversation.

    If the conversation exists, show the conversation message history.  Then run a user driven loop
    prompting for input and then streaming the response.
    """
    logfire.configure(
        console=False,
        service_name=os.getenv("LOGFIRE_SERVICE_NAME"),
        token=os.getenv("LOGFIRE_TOKEN"),
    )
    logfire.instrument_pydantic_ai()

    agent_anth = services.agents.create_agent_general(
        builtins=[pydantic_ai.WebSearchTool(max_uses=1, search_context_size="low")],
        model=services.agents.model_anthropic(),
        # tools=services.tools.list(),
    )

    agent_places = services.agents.create_agent_places(
        model=services.agents.model_gemini(),
        output_types=services.places.functions.list(),
    )

    channel_anth = services.agents.AgentChannel(
        agent=agent_anth, conv_id=conv_id, iq=asyncio.Queue(), oq=asyncio.Queue(), user_id=user_id
    )

    channel_task = asyncio.create_task(services.agents.stream_task(channel=channel_anth))

    print("")

    try:
        # get history block
        while True:
            kind: str
            name: str

            kind, name, msg = await channel_anth.oq.get()

            if kind in ["history-end", "history-start"]:
                if kind == "history-end":
                    break
            elif kind == "history-msg" and name == "model-msg":
                output_struct = services.agents.output_model_msg(model_msg=msg)
                output_nodes = output_struct.nodes
                node_index = 0

                while node_index < len(output_nodes):
                    output_node = output_nodes[node_index]

                    if output_node.name in ["user-prompt"]:
                        services.console.print_fragment_user(f"user: {output_node.text}", end="\n\n")
                    elif output_node.name in ["builtin-tool-call", "builtin-tool-return", "tool-call", "tool-return"]:
                        services.console.print_fragment_tool(f"{output_node.name}: {output_node.text}", end="\n\n")
                    elif output_node.name in ["model-text"]:
                        # collect model-text nodes
                        node_index, text = services.agents.output_nodes_collect(
                            output_nodes=output_nodes, name="model-text", index=node_index
                        )
                        services.console.print_fragment_model(text, end="\n\n")
                    elif output_node.name in ["model-end"]:
                        # todo
                        services.console.print_fragment_model("model-end", end="\n\n")

                    node_index += 1
    except Exception as e:
        services.console.print_error(f"channel exception - {e}")

    msg_delta: (
        pydantic_ai.messages.TextPartDelta
        | pydantic_ai.messages.ThinkingPartDelta
        | pydantic_ai.messages.ToolCallPartDelta
    ) = None

    msg_part: (
        pydantic_ai.messages.TextPart
        | pydantic_ai.messages.ToolCallPart
        | pydantic_ai.messages.BuiltinToolCallPart
        | pydantic_ai.messages.BuiltinToolReturnPart
        | pydantic_ai.messages.ThinkingPart
    ) = None

    try:
        turn_mode = "user"
        request_id = ""

        # user input loop
        while True:
            user_prompt = input("user: ")

            if re.match(r"^(bye|exit|quit)", user_prompt):
                services.console.print_ok(f"\nconversation {channel_anth.conv_id} exiting")
                break

            if re.match(r"^(break|breakpoint|debug)", user_prompt):
                services.console.print_ok(f"\nconversation {channel_anth.conv_id} debugger")
                breakpoint()

            print("")

            with services.database.session.get() as db_session:
                tool_use = services.places.functions.match_tool_use(db_session=db_session, query=user_prompt)

                if tool_use:
                    # run agent with registered output tools
                    agent_result = await agent_places.run(user_prompt=user_prompt, deps={})

                    services.console.print_fragment_model(services.agents.output_tool(output=agent_result.output))
                else:
                    if channel_anth.conv_id == 0:
                        # create new conversation
                        code, conv_db = services.convs.create(
                            db_session=db_session, name=f"c-{ulid.new().str}", user_id=user_id
                        )
                        channel_anth.conv_id = conv_db.id

                    # generate a new conv request object
                    code, conv_id, req_db = services.convs.reqs.create(
                        db_session=db_session,
                        conv_id=channel_anth.conv_id,
                        data={
                            "user_prompt": user_prompt,
                        },
                        request_id=ulid.new().str,
                        state=models.conv_req.STATE_PENDING,
                        user_id=channel_anth.user_id,
                    )

                    request_id = req_db.request_id

                    await channel_anth.iq.put(["user-prompt", {"text": user_prompt, "request_id": request_id}])

                    turn_mode = "agent"

                    while turn_mode == "agent":
                        kind: str
                        name: str

                        kind, name, msg = await channel_anth.oq.get()

                        # print(f"kind: {kind}")
                        # print(f"name: {name}")
                        # print(msg)
                        # print("")

                        if kind in ["agent-node"]:
                            # name values literals:
                            # user-prompt, model-request-start, model-request-end, tool-call-start, tool-call-end, turn-end
                            if name in ["model-request-end", "tool-call-end"]:
                                print("")
                            elif name == "turn-end":
                                turn_mode = "user"
                        elif kind in ["stream-event"]:
                            # name values literals:
                            # model-request, tool-call
                            if name == "model-request":
                                if isinstance(msg, pydantic_ai.messages.PartDeltaEvent):
                                    msg_delta = msg.delta
                                    if isinstance(msg_delta, pydantic_ai.messages.TextPartDelta):
                                        services.console.print_fragment_model(msg_delta.content_delta, end="")
                                elif isinstance(msg, pydantic_ai.messages.PartStartEvent):
                                    msg_part = msg.part
                                    if isinstance(msg_part, pydantic_ai.messages.TextPart):
                                        services.console.print_fragment_model(msg_part.content, end="")
    except asyncio.CancelledError as e:
        services.console.print_error(f"channel request {request_id} cancelled - {e}")

        # mark request as cancelled
        services.convs.reqs.update_state(
            db_session=db_session,
            request_id=request_id,
            state_from=models.conv_req.STATE_PENDING,
            state_to=models.conv_req.STATE_CANCELLED,
            conv_msg_ids=[],
        )
    except Exception as e:
        services.console.print_error(f"channel exception - {e}")

        # mark request as error
        services.convs.reqs.update_state(
            db_session=db_session,
            request_id=request_id,
            state_from=models.conv_req.STATE_PENDING,
            state_to=models.conv_req.STATE_ERROR,
            conv_msg_ids=[],
        )

    channel_task.cancel()

    try:
        await channel_task
    except asyncio.CancelledError:
        services.console.print_error("channel task cancelled, normal exit")


cli.add_command(conv_delete)
cli.add_command(conv_load)
cli.add_command(conv_start)

if __name__ == "__main__":
    cli()
